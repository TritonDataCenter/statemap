/*
 * Copyright 2018 Joyent, Inc.
 */ 

extern crate memmap;
extern crate serde;
extern crate serde_json;
extern crate natord;
extern crate palette;
extern crate rand;

/*
 * The StatemapInput* types denote the structure of the concatenated JSON
 * in the input file.
 */
#[derive(Deserialize, Debug)]
struct StatemapInputState {
    color: Option<String>,                  // color for state, if any
    value: usize,                           // value for state
}

#[derive(Deserialize, Debug)]
struct StatemapInputDatum {
    time: String,                           // time of this datum
    entity: String,                         // name of entity
    state: u32,                             // state entity is in at time
}

#[derive(Deserialize, Debug)]
struct StatemapInputDescription {
    entity: String,                         // name of entity
    description: String,                    // description of entity
}

#[derive(Deserialize, Debug)]
#[allow(non_snake_case)]
struct StatemapInputMetadata {
    start: Vec<u64>,
    title: String,
    host: Option<String>,
    entityKind: Option<String>,
    states: HashMap<String, StatemapInputState>,
}

#[derive(Deserialize, Debug)]
struct StatemapInputEvent {
    time: String,                           // time of this datum
    entity: String,                         // name of entity
    event: String,                          // type of event
    target: Option<String>,                 // target for event, if any
}

#[derive(Copy,Clone,Debug)]
pub struct Config {
    pub maxrect: u64,
    pub begin: u64,
    pub end: u64,
    pub notags: bool,
}

/*
 * These fields are dropped directly into the SVG.
 */
#[derive(Debug,Serialize)]
#[allow(non_snake_case)]
pub struct StatemapSVGConfig {
    pub stripHeight: u32,
    pub legendWidth: u32,
    pub tagWidth: u32,
    pub stripWidth: u32,
    pub background: String,
    pub sortby: Option<String>,
}

#[derive(Copy,Clone,Debug)]
struct StatemapColor {
    color: Color,                           // underlying color
}

#[derive(Debug)]
struct StatemapRect {
    start: u64,                             // nanosecond offset
    duration: u64,                          // nanosecond duration
    weight: u64,                            // my weight + neighbors
    states: Vec<u64>,                       // time spent in each state
    prev: Option<u64>,                      // previous rectangle
    next: Option<u64>,                      // next rectangle
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
struct StatemapRectWeight {
    weight: u64,                            // weight for this rect
    start: u64,                             // start time for this rect
    entity: usize,                          // entity for this rect
}

#[derive(Default,Clone,Debug,Serialize)]
struct StatemapState {
    name: String,                           // name of this state
    color: Option<String>,                  // color of this state, if any
}

#[derive(Debug)]
struct StatemapEntity {
    name: String,                           // name of this entity
    id: usize,                              // identifier
    description: Option<String>,            // description, if any
    last: Option<u64>,                      // last start time
    start: Option<u64>,                     // current start time
    state: Option<u32>,                     // current state
    rects: HashMap<u64, RefCell<StatemapRect>>, // rectangles for this entity
}

#[derive(Debug)]
pub struct Statemap {
    config: Config,                         // configuration
    metadata: Option<StatemapInputMetadata>, // in-stream metadata
    line: u64,                              // current line number
    nrecs: u64,                             // number of records
    nevents: u64,                           // number of events
    entities: HashMap<String, StatemapEntity>, // hash of entities
    states: Vec<StatemapState>,             // vector of valid states
    byid: Vec<String>,                      // entities by ID
    byweight: BTreeSet<StatemapRectWeight>  // rectangles by weight
}

#[derive(Debug)]
pub struct StatemapError {
    errmsg: String
}

#[derive(Serialize)]
#[allow(non_snake_case)]
struct StatemapSVGGlobals<'a> {
    begin: u64,
    end: u64,
    entityPrefix: String,
    pixelHeight: u32,
    pixelWidth: u32,
    totalHeight: u32,
    timeWidth: u64,
    lmargin: u32,
    tmargin: u32,
    states: &'a [StatemapState],
    start: &'a [u64],
    entityKind: &'a str,
}

use std::fs::File;
use std::fs;
use std::str;
use std::error::Error;
use std::fmt;
use std::collections::HashMap;
use std::collections::BTreeSet;
use std::str::FromStr;
use std::cell::RefCell;
use std::cmp;

#[cfg(test)]
use std::collections::HashSet;

use self::memmap::MmapOptions;
use self::palette::{Srgb, Color, Mix};

impl Default for Config {
    fn default() -> Config {
        Config { 
            maxrect: 25000,
            begin: 0,
            end: 0,
            notags: true,
        }
    }
}

impl Default for StatemapSVGConfig {
    fn default() -> StatemapSVGConfig {
        StatemapSVGConfig {
            stripHeight: 10,
            legendWidth: 138,
            stripWidth: 862,
            tagWidth: 250,
            background: "#f0f0f0".to_string(),
            sortby: None,
        }
    }
}

impl StatemapError {
    fn new(statemap: &Statemap, msg: &str) -> StatemapError {
        if msg.starts_with("?") {
            StatemapError { errmsg: format!("illegal datum on line {}: {}",
              statemap.line, &msg[1..])}
        } else {
            StatemapError { errmsg: msg.to_string() }
        }
    }
}

impl fmt::Display for StatemapError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.errmsg)
    }
}

impl Error for StatemapError {
    fn description(&self) -> &str {
        &self.errmsg
    }
}

impl FromStr for StatemapColor {
    type Err = StatemapError;

    fn from_str(name: &str) -> Result<StatemapColor, StatemapError> {
        let named = palette::named::from_str(name);

        match named {
            Some(color) => {
                let rgb = Srgb::<f32>::from_format(color);

                return Ok(StatemapColor {
                    color: rgb.into_format().into_linear().into()
                });
            }
            None => {}
        }

        if name.len() == 7 && name.chars().next().unwrap() == '#' {
            let r = u8::from_str_radix(&name[1..3], 16);
            let g = u8::from_str_radix(&name[3..5], 16);
            let b = u8::from_str_radix(&name[5..7], 16);

            if r.is_ok() && g.is_ok() && b.is_ok() {
                let rgb = Srgb::new(r.unwrap(), g.unwrap(), b.unwrap());

                return Ok(StatemapColor {
                    color: rgb.into_format().into_linear().into()
                });
            }
        }

        return Err(StatemapError { 
            errmsg: format!("\"{}\" is not a valid color", name)
        });
    }
}

impl fmt::Display for StatemapColor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let rgb = Srgb::from_linear(self.color.into()).into_components();

        write!(f, "rgb({}, {}, {})", (rgb.0 * 256.0) as u8,
            (rgb.1 * 256.0) as u8, (rgb.2 * 256.0) as u8)
    }
}

impl StatemapColor {
    fn random() -> Self {
        let rgb = Srgb::new(rand::random::<u8>(), rand::random::<u8>(),
            rand::random::<u8>());

        StatemapColor {
            color: rgb.into_format().into_linear().into()
        }
    }

    fn _mix(&self, other: &Self, ratio: f32) -> Self {
        StatemapColor {
            color: self.color.mix(&other.color, ratio)
        }
    }

    fn mix_nonlinear(&self, other: &Self, ratio: f32) -> Self {
        let lhs = Srgb::from_linear(self.color.into()).into_components();
        let rhs = Srgb::from_linear(other.color.into()).into_components();

        let recip = 1.0 - ratio;

        let rgb = Srgb::<f32>::new(lhs.0 as f32 * recip + rhs.0 as f32 * ratio,
            lhs.1 as f32 * recip + rhs.1 as f32 * ratio,
            lhs.2 as f32 * recip + rhs.2 as f32 * ratio);

        StatemapColor {
            color: rgb.into_format().into_linear().into()
        }
    }
}

impl StatemapRect {
    fn new(start: u64, duration: u64, state: u32, nstates: u32) -> Self {
        let mut r = StatemapRect {
            start: start,
            duration: duration,
            states: vec![0; nstates as usize],
            prev: None,
            next: None,
            weight: duration
        };

        r.states[state as usize] = duration;
        r
    }
}

impl StatemapEntity {
    fn new(name: &str, id: usize) -> Self {
        StatemapEntity {
            name: name.to_string(),
            start: None,
            description: None,
            last: None,
            state: None,
            rects: HashMap::new(),
            id: id,
        }
    }

    fn newrect(&mut self, end: u64, nstates: u32)
        -> (Option<(u64, u64, u64)>, (u64, u64))
    {
        let start = self.start.unwrap();
        let lhs: Option<(u64, u64, u64)>;
        let rhs: (u64, u64);
        let mut rect = StatemapRect::new(start,
            end - start, self.state.unwrap(), nstates);

        rect.prev = self.last;

        match self.last {
            Some(last) => {
                let mut lrect = self.rects.get(&last).unwrap().borrow_mut();
                let old = lrect.weight;

                lrect.next = Some(start);
                rect.weight += lrect.duration;
                lrect.weight += rect.duration;

                lhs = Some((lrect.start, old, lrect.weight));
            }
            _ => { lhs = None; }
        }

        rhs = (rect.start, rect.weight);
        self.rects.insert(start, RefCell::new(rect));
        (lhs, rhs)
    }

    fn addto(&mut self, rect: u64, delta: u64) -> u64 {
        let mut r = self.rects.get(&rect).unwrap().borrow_mut();
        let old = r.weight;

        r.weight += delta;
        old
    }

    fn subsume(&mut self, victim: u64)
        -> ((Option<u64>, u64), (u64, u64), (u64, u64), ((Option<u64>, u64)))
    {
        let mut last = self.last;
        let subsumed: u64;
        let rval;

        /*
         * We return three weights that need to be adjusted: that of the
         * rectangle to the left (post-subsume), that of the rectangle to
         * the right (post-subsume) and that of the center rectangle.  Each
         * of these adjustments is described as a start plus a weight to be
         * added -- and all three are returned as a tuple that also includes
         * the subsumed rectangle that needs to be removed.
         */
        let ldelta: (Option<u64>, u64);
        let cdelta: (u64, u64);
        let rdelta: (Option<u64>, u64);

        /*
         * We create a scope here to help out the borrow checker in terms of
         * knowing that our immutable borrow of self.rects is being dropped
         * before our mutable borrow of it, below.
         */
        {
            let left: &RefCell<StatemapRect>;
            let right: &RefCell<StatemapRect>;

            /*
             * We create a scope here to allow the borrow of the victim
             * cell fall out of scope as we may need it to be mutable, below.
             */
            {
                let vcell = self.rects.get(&victim).unwrap();
                let v = vcell.borrow();

                match (v.prev, v.next) {
                    (None, None) => panic!("nothing to subsume"),
                    (Some(prev), None) => {
                        left = self.rects.get(&prev).unwrap();
                        right = vcell;

                        let lref = left.borrow();
                        ldelta = (lref.prev, v.duration);
                        cdelta = (lref.start, 0);
                        rdelta = (None, 0);
                    }
                    (None, Some(next)) => {
                        left = vcell;
                        right = self.rects.get(&next).unwrap();

                        /*
                         * We want the weight of the remaining (center)
                         * rectangle to be the weight of our right rectangle;
                         * to express this as a delta, we express it as the
                         * difference between the two.
                         */
                        let rref = right.borrow();
                        ldelta = (None, 0);
                        cdelta = (v.start, rref.weight - v.weight);
                        rdelta = (rref.next, v.duration);
                    }
                    (Some(prev), Some(next)) => {
                        /*
                         * We want whichever of our neighboring rectangles is
                         * shorter to subsume us.
                         */
                        let l = self.rects.get(&prev).unwrap();
                        let r = self.rects.get(&next).unwrap();

                        let lref = l.borrow();
                        let rref = r.borrow();

                        if lref.duration < rref.duration {
                            left = l;
                            right = vcell;

                            ldelta = (lref.prev, v.duration);
                            cdelta = (lref.start, v.weight -
                                (lref.duration + v.duration));
                            rdelta = (Some(rref.start), lref.duration);
                        } else {
                            left = vcell;
                            right = r;

                            ldelta = (Some(lref.start), rref.duration);
                            cdelta = (v.start, rref.weight -
                                (rref.duration + v.duration));
                            rdelta = (rref.next, v.duration);
                        }
                    }
                }
            }

            let mut s = left.borrow_mut();
            let v = right.borrow();

            s.next = v.next;

            /*
             * Set our subsumed next rectangle's previous to point back to us
             * rather than the subsumed rectangle.
             */
            match s.next {
                Some(next) => {
                    self.rects.get(&next).unwrap()
                        .borrow_mut().prev = Some(s.start);
                }
                None => {
                    last = Some(s.start);
                }
            }

            /*
             * Add our duration, and then sum the value in each of the states.
             */
            s.duration += v.duration;

            for i in 0..v.states.len() {
                s.states[i] += v.states[i];
            }

            subsumed = v.start;
            rval = (v.start, v.weight);
        }

        /*
         * Okay, we're done subsuming! We can remove the subsumed rectangle.
         */
        self.rects.remove(&subsumed);
        self.last = last;

        (ldelta, cdelta, rval, rdelta)
    }

    #[must_use]
    fn apply(&mut self, deltas: ((Option<u64>, u64),
        (u64, u64), (u64, u64), ((Option<u64>, u64)))) ->
        Vec<(u64, u64, Option<u64>)>
    {
        let mut updates: Vec<(u64, u64, Option<u64>)> = vec![];

        /*
         * Handle the left delta.
         */
        match (deltas.0).0 {
            Some(rect) => {
                let delta = (deltas.0).1;
                updates.push((rect, self.addto(rect, delta), Some(delta)));
            }
            None => {}
        }

        /*
         * Handle the center delta.
         */
        let rect = (deltas.1).0;
        let delta = (deltas.1).1;
        updates.push((rect, self.addto(rect, delta), Some(delta)));

        /*
         * Handle the subsumed rectangle by pushing a delta update of None.
         */
        updates.push(((deltas.2).0, (deltas.2).1, None));

        /*
         * And finally, the right delta.
         */
        match (deltas.3).0 {
            Some(rect) => {
                let delta = (deltas.3).1;
                updates.push((rect, self.addto(rect, delta), Some(delta)));
            }
            None => {}
        }

        updates
    }

    fn output_svg(&self, config: &StatemapSVGConfig,
        globals: &StatemapSVGGlobals,
        colors: &[StatemapColor], y: u32) -> Vec<String>
    {
        let rect_width = |rect: &StatemapRect| -> f64 {
            /*
             * We add a fuzz factor to our width to assure it will always be
             * nearly (but not quite!) half a pixel wider than it should be.
             * This assures that none of the background (which is deliberately a
             * bright color) comes through at the border of rectangles, without
             * losing any accuracy (the next rectangle will tile over ours at
             * an unadjusted offset).
             */
            ((rect.duration as f64 / globals.timeWidth as f64) *
                globals.pixelWidth as f64) + 0.4 as f64
        };

        let mut x: f64;
        let mut map: Vec<u64>;
        let mut data: Vec<String> = vec![];
        
        map = self.rects.values().map(|r| r.borrow().start).collect();
        map.sort();

        if map.len() > 0 {
            x = ((map[0] - globals.begin) as f64 /
                globals.timeWidth as f64) * globals.pixelWidth as f64;
        } else {
            x = globals.pixelWidth as f64;
        }
            
        println!(r##"<rect x="0" y="{}" width="{}"
            height="{}" style="fill:{}" />"##, y, x, config.stripHeight,
            config.background);

        println!(r##"<g id="{}{}"><title>{} {}</title>"##,
            globals.entityPrefix, self.name, globals.entityKind, self.name);

        for i in 0..map.len() {
            let rect = self.rects.get(&map[i]).unwrap().borrow();
            let mut state = None;
            let mut blended = false;

            x = ((map[i] - globals.begin) as f64 /
                globals.timeWidth as f64) * globals.pixelWidth as f64;

            for j in 0..rect.states.len() {
                if rect.states[j] != 0 {
                    match state {
                        None => { state = Some(j) },
                        Some(_s) => {
                            blended = true;
                            break;
                        }
                    }
                }
            }

            if !blended {
                assert!(state.is_some());

                data.push(format!("{{ t: {}, s: {} }}",
                    rect.start, state.unwrap()));

                println!(concat!(r##"<rect x="{}" y="{}" width="{}" "##,
                    r##"height="{}" onclick="mapclick(evt, {})" "##,
                    r##"style="fill:{}" />"##),
                    x, y, rect_width(&rect), config.stripHeight,
                    data.len() - 1, colors[state.unwrap()]);

                continue;
            }

            let max = rect.states.iter().enumerate()
                .max_by(|&(_, lhs), &(_, rhs)| lhs.cmp(rhs)).unwrap().0;

            let mut color = colors[max];
            let mut datum = format!("{{ t: {}, s: {{ ", rect.start);
            let mut comma = "";
            
            for j in 0..rect.states.len() {
                if rect.states[j] == 0 {
                    continue;
                }

                let ratio = rect.states[j] as f64 / rect.duration as f64;

                datum.push_str(&format!("{}'{}': {:.3}", comma, j, ratio));
                comma = ", ";

                if j != max {
                    color = color.mix_nonlinear(&colors[j], ratio as f32);
                }
            }

            datum.push_str("} }");
            data.push(datum);

            println!(concat!(r##"<rect x="{}" y="{}" width="{}" "##,
                r##"height="{}" onclick="mapclick(evt, {})" "##,
                r##"style="fill:{}" />"##), x, y, rect_width(&rect),
                config.stripHeight, data.len() - 1, color);
        }
        
        println!("</g>");
        data
    }

    #[cfg(test)]
    fn print(&self, header: &str) {
        let mut v: Vec<u64>;
        let l: usize;
        
        v = self.rects.values().map(|r| r.borrow().start).collect();
        v.sort();
        l = v.len();

        for i in 0..l {
            let me = self.rects.get(&v[i]).unwrap().borrow();
            println!("{}: entity={}: [{}] {:?}: {:?}",
                header, self.id, i, v[i], me);
        }

        println!("{}: entity={}: last is {:?}", header, self.id, self.last);
    }

    #[cfg(test)]
    fn verify(&self) {
        let mut v: Vec<u64>;
        let l: usize;
        
        v = self.rects.values().map(|r| r.borrow().start).collect();
        v.sort();
        l = v.len();

        for i in 0..l {
            let me = self.rects.get(&v[i]).unwrap().borrow();
            let mut weight = me.duration;

            if i < l - 1 {
                let next = self.rects.get(&v[i + 1]).unwrap().borrow();
                assert_eq!(me.next, Some(next.start));
                assert!(me.start < next.start);
                weight += next.duration;
            } else {
                assert_eq!(me.next, None);
                assert_eq!(self.last, Some(me.start));
            }

            if i > 0 {
                let prev = self.rects.get(&v[i - 1]).unwrap().borrow();
                assert_eq!(me.prev, Some(prev.start));
                assert!(me.start > prev.start);
                weight += prev.duration;
            } else {
                assert_eq!(me.prev, None);
            }

            assert_eq!(me.weight, weight);
        }
    }

    #[cfg(test)]
    fn subsume_apply_and_verify(&mut self, victim: u64) ->
        Vec<(u64, u64, Option<u64>)>
    {
        println!("=== Subsuming {}", victim);
        self.print(&format!("Before subsuming {}", victim));
        self.verify();

        let tup = self.subsume(victim);
        println!("Weight delta from subsuming {}: {:?}", victim, tup);

        self.print(&format!("After subsuming {}, before applying", victim));
        let updates = self.apply(tup);

        self.print(&format!("After subsuming {}, after applying", victim));
        self.verify();
        updates
    }
}

impl Statemap {
    pub fn new(config: &Config) -> Self {
        Statemap {
            config: *config,
            line: 1,
            nrecs: 0,
            nevents: 0,
            entities: HashMap::new(),
            states: Vec::new(),
            byid: Vec::new(),
            byweight: BTreeSet::new(),
            metadata: None,
        }
    }

    fn err(&self, msg: &str) -> Result<(), Box<Error>>  {
        Err(Box::new(StatemapError::new(self, msg)))
    }

    fn json_start(&mut self, current: &str) ->
        Result<usize, StatemapError>
    {
        let iter = current.chars();
        let mut idx = 0;

        for c in iter {
            match c {
                '{' => return Ok(idx),
                '\n' => self.line += 1,
                c if c.is_whitespace() => {},
                _ => {
                    let errmsg = format!(concat!("line {}: illegal JSON ",
                        "delimiter (\"{}\")\n"), self.line, c);
                    return Err(StatemapError::new(self, &errmsg));
                }
            }
            idx += 1;
        }

        Ok(idx)
    }

    fn json_end(&mut self, current: &str) -> Result<usize, StatemapError> {
        let mut iter = current.chars();
        let first = iter.next();
        let start = self.line;

        assert_eq!(first, Some('{'));

        let mut idx: usize = 0;
        let mut notinstring = 1;
        let mut backslashed = false;
        let mut depth = 1;

        for c in iter {
            idx += 1;

            if c == '\n' {
                self.line += 1;
            }

            if backslashed {
                backslashed = false;
                continue;
            }

            match c {
                '"' => notinstring ^= 1,
                '\\' => backslashed = true,
                '{' => depth += notinstring,
                '}' => {
                    depth -= notinstring;

                    if depth == 0 {
                        /*
                         * We return the index beyond the end to assure that
                         * a [start..end] slice yields the entire payload.
                         */
                        return Ok(idx + 1);
                    }
                }
                _ => continue
            }
        }

        let errmsg = format!("unterminated JSON starting at line {}", start);
        Err(StatemapError::new(self, &errmsg))
    }

    fn entity_lookup(&mut self, name: &str) -> &mut StatemapEntity {
        /*
         * The lack of non-lexical lifetimes causes this code to be a bit
         * gnarlier than it should really have to be.
         */
        if self.entities.contains_key(name) {
            return match self.entities.get_mut(name) {
                Some(entity) => { entity },
                None => unreachable!()
            };
        }

        let entity = StatemapEntity::new(name, self.byid.len());
        self.byid.push(name.to_string());

        self.entities.insert(name.to_string(), entity);
        self.entities.get_mut(name).unwrap()
    }

    /*
     * Takes a vector of updates to apply to our byweight tree as well as a
     * template rectangle weight and applies the updates.
     */
    fn apply(&mut self, updates: Vec<(u64, u64, Option<u64>)>,
        rweight: &mut StatemapRectWeight)
    {
        for i in 0..updates.len() {
            rweight.start = updates[i].0;
            rweight.weight = updates[i].1;

            self.byweight.remove(rweight);

            match updates[i].2 {
                Some(delta) => {
                    rweight.weight += delta;
                    self.byweight.insert(*rweight);
                }
                None => {}
            }
        }
    }

    /*
     * Subsumes the rectangle of least weight, applies the deltas to the
     * entity corresponding to that rectangle, and then applies the
     * resulting rectangle weight updates.
     */
    fn trim(&mut self) {
        let mut remove: StatemapRectWeight;
        let updates;

        remove = *self.byweight.iter().next().unwrap();
        self.byweight.remove(&remove);
        
        /*
         * We need a scope here to help the compiler out with respect to
         * our use of entity.
         */
        {
            let name = &self.byid[remove.entity];
            let entity = self.entities.get_mut(name).unwrap();

            if entity.rects.len() == 1 {
                /*
                 * If this entity only has one rectangle, than there is
                 * nothing to subsume; we simply return.  (This weight has
                 * already been removed, so we won't find it again until
                 * another rectangle is added for this entity.)
                 */
                return;
            }

            let deltas = entity.subsume(remove.start);
            updates = entity.apply(deltas);
        }

        self.apply(updates, &mut remove);
    }

    #[must_use]
    fn sort(&self, sortby: Option<usize>) -> Vec<usize>
    {
        let mut v: Vec<(u64, &String, usize)>;

        let values = self.entities.values();

        match sortby {
            None => { v = values.map(|e| (0, &e.name, e.id)).collect(); },
            Some(state) => {
                v = values.map(|e| {
                    let ttl = e.rects.values().fold(0, |i, r| {
                        i + r.borrow().states[state]
                    });

                    (ttl, &e.name, e.id)
                }).collect();
            }
        }

        v.sort_by(|&a, &b| {
            let result = b.0.cmp(&a.0);

            if result == cmp::Ordering::Equal {
                natord::compare(a.1, b.1)
            } else {
                result
            }
        });

        v.iter().map(|e| e.2).collect()
    }

    #[cfg(test)]
    fn verify(&self) {
        /*
         * First, verify each of the entities.
         */
        for entity in self.entities.values() {
            entity.verify();
        }

        /*
         * Verify that each rectangle in each entity can be found in our
         * byweight set -- and that the weights match.
         */
        for entity in self.entities.values() {
            for cell in entity.rects.values() {
                let rect = cell.borrow();

                let rweight = StatemapRectWeight {
                    entity: entity.id,
                    weight: rect.weight,
                    start: rect.start
                };

                assert!(self.byweight.contains(&rweight) ||
                    entity.rects.len() == 1);
            }
        }

        let mut present = HashSet::new();

        /*
         * Verify that each entity is valid that each entity/start tuple is
         * present exactly once.
         */
        for rweight in self.byweight.iter() {
            let name = &self.byid[rweight.entity];
            let tup = (rweight.entity, rweight.start);

            assert!(self.entities.get(name).is_some());

            let entity = self.entities.get(name).unwrap();

            assert!(entity.rects.get(&rweight.start).is_some());
            assert!(!present.contains(&tup));
            present.insert(tup);
        }
    }

    #[cfg(test)]
    fn subsume_apply_and_verify(&mut self, what: &str, victim: u64) {
        let id: usize;
        let mut weight: Option<u64> = None;
        let updates;

    {
        let entity = self.entity_lookup(what);
            updates = entity.subsume_apply_and_verify(victim);
            id = entity.id;
        }

        /*
         * Before we verify, remove the victim -- if it wasn't actually
         * to be removed, we'll add it back when we apply the updates.
         */
        for rweight in self.byweight.iter() {
            if rweight.entity == id && rweight.start == victim {
                assert!(weight.is_none());
                weight = Some(rweight.weight);
            }
        }

        assert!(weight.is_some());

        let mut rweight = StatemapRectWeight {
            entity: id, weight: 0, start: 0
        };

        self.apply(updates, &mut rweight);
        self.print(&format!("After subsuming {} from {}", victim, what)); 
        self.verify();
    }

    #[cfg(test)]
    fn print(&self, header: &str) {
        println!("{}: by weight: {:?}", header, self.byweight);

        for entity in self.entities.values() {
            entity.print(header);
        }

        println!("");
    }

    #[cfg(test)]
    fn get_rects(&self, entity: &str) -> Vec<(u64, u64, Vec<u64>)> {
        let mut rval: Vec<(u64, u64, Vec<u64>)>;

        let e = self.entities.get(entity);

        match e {
            Some(entity) => {
                rval = entity.rects.values().map(|r| {
                    let rect = r.borrow();

                    (rect.start, rect.duration, rect.states.clone())
                }).collect();

                rval.sort();
            },
            None => { rval = vec![]; }
        }

        rval
    }

    fn ingest_metadata(&mut self, payload: &str) -> Result<(), Box<Error>> {
        let metadata: StatemapInputMetadata = serde_json::from_str(payload)?;
        let nstates = metadata.states.len();
        let mut states: Vec<Option<StatemapState>> = vec![None; nstates];

        if metadata.start.len() != 2 {
            return self.err(concat!("\"start\" property must be a ",
                "two element array"));
        }

        for (key, value) in &metadata.states {
            let ndx = value.value;

            if ndx >= nstates {
                let errmsg = format!(concat!("state \"{}\" has value ({}) ",
                    "that exceeds maximum allowed value ({})"),
                    key, ndx, nstates - 1);
                return self.err(&errmsg);
            }

            if ndx < states.len() && states[ndx].is_some() {
                let errmsg = format!(concat!("state \"{}\" has value ",
                    "({}) that conflicts with state \"{}\""), key,
                    ndx, states[ndx].as_ref().unwrap().name);

                return self.err(&errmsg);
            }

            states[ndx] = Some(StatemapState {
                name: key.to_string(),
                color: match value.color {
                    Some(ref str) => { Some(str.to_string()) },
                    None => { None }
                }
            });
        }

        assert_eq!(self.states.len(), 0);

        /*
         * We have verified our states; now pull them into our array.
         */
        for _i in 0..nstates {
            self.states.push(states.remove(0).unwrap());
        }

        self.metadata = Some(metadata);

        Ok(())
    }

    fn ingest_end(&mut self) {
        let mut end = self.config.end;

        if end == 0 {
            /*
             * If we weren't given an ending time, take a lap through all
             * of our entities to find the one with the latest time.
             */
            end = self.entities.values().fold(0, |latest, e| {
                match e.start {
                    Some(start) => cmp::max(latest, start),
                    None => latest
                }
            });
        }

        let nstates = self.states.len() as u32;

        for entity in self.entities.values_mut() {
            match entity.start {
                Some(start) if start < end => {
                    /*
                     * We are adding a rectangle, but because we are now done
                     * with ingestion, we are not updating the rectangle weight
                     * tree and we are not going to subsume any rectangles; we
                     * can safely ignore the return value.
                     */
                    entity.newrect(end, nstates);
                },
                _ => {}
            }
        }
    }

    fn ingest_datum(&mut self, payload: &str) -> Result<(), Box<Error>> {
        let parsed: Result<StatemapInputDatum, serde_json::Error>;

        parsed = serde_json::from_str(payload);

        match parsed {
            Ok(datum) => { 
                let time: u64;
                let nstates: u32 = self.states.len() as u32;

                match <u64>::from_str(&datum.time) {
                    Ok(t) => time = t,
                    _ => return self.err("?illegal time value")
                }

                /*
                 * If the time of this datum is after our specified end time,
                 * we have nothing further to do to process it.
                 */
                if self.config.end > 0 && time > self.config.end {
                    return Ok(());
                }

                if datum.state >= nstates {
                    return self.err("?illegal state value");
                }

                let begin = self.config.begin;
                let mut errmsg: Option<String> = None;
                let mut insert: Option<StatemapRectWeight> = None;
                let mut update: Option<(StatemapRectWeight, u64)> = None;

                /*
                 * We are going to do a lookup of our entity, but this will
                 * cause us to lose our reference on self (mutable or
                 * otherwise) -- which we need to fully record any error.  To
                 * implement this absent non-lexical lifetimes, we put the
                 * entity in a lexical scope implemented with "loop" so we
                 * can break out of it on an error condition.
                 */
                loop {
                    let name = &datum.entity;
                    let entity = self.entity_lookup(name);

                    match entity.start {
                        Some(start) => {
                            if time < start {
                                errmsg = Some(format!(concat!("?time {} is out",
                                    " of order with respect to prior time {}"),
                                    time, start));
                                break;
                            }

                            if time > begin {
                                /*
                                 * We can now create a new rectangle for this
                                 * entity's past state.
                                 */
                                if start < begin {
                                    entity.start = Some(begin);
                                }

                                let rval = entity.newrect(time, nstates);
                                entity.last = entity.start;

                                match rval.0 {
                                    Some(rect) => {
                                        update = Some((StatemapRectWeight {
                                            weight: rect.1,
                                            start: rect.0,
                                            entity: entity.id
                                        }, rect.2));
                                    }
                                    None => {}
                                }

                                insert = Some(StatemapRectWeight {
                                    weight: (rval.1).1,
                                    start: (rval.1).0,
                                    entity: entity.id
                                });
                            }
                        }
                        None => {}
                    }

                    entity.start = Some(time);
                    entity.state = Some(datum.state);
                    break;
                }

                if errmsg.is_some() {
                    return self.err(&errmsg.unwrap());
                }

                if update.is_some() {
                    let mut rweight = update.unwrap().0;
                    self.byweight.remove(&rweight);
                    rweight.weight = update.unwrap().1;
                    self.byweight.insert(rweight);
                }

                if insert.is_some() {
                    self.byweight.insert(insert.unwrap());
                }

                return Ok(());
            }
            _ => {}
        }

        let parsed: Result<StatemapInputDescription, serde_json::Error>;
        parsed = serde_json::from_str(payload);

        match parsed {
            Ok(datum) => {
                let entity = self.entity_lookup(&datum.entity);
                entity.description = Some(datum.description.to_string());

                return Ok(());
            }
            _ => {}
        }

        let parsed: Result<StatemapInputEvent, serde_json::Error>;
        parsed = serde_json::from_str(payload);

        match parsed {
            Ok(_datum) => {
                /*
                 * Right now, we don't do anything with events -- but the
                 * intent is to be able to render these in the statemap, so
                 * we also don't reject them.
                 */
                self.nevents += 1;

                return Ok(());
            }
            _ => {}
        }

        self.err("?unrecognized payload")
    }

    pub fn ingest(&mut self, filename: &str) -> Result<(), Box<Error>> {
        let stat = fs::metadata(filename)?;
        let file = File::open(filename)?;
        let len: usize = stat.len() as usize;
        let mut nrecs = 0;

        let mmap = unsafe { MmapOptions::new().map(&file)? };

        let contents = str::from_utf8(&mmap[..])?;

        let mut start = self.json_start(contents)?;

        if start == len {
            return self.err("missing metadata payload");
        }

        let mut end = self.json_end(contents)?;

        self.ingest_metadata(&contents[start..end])?;

        /*
         * Now rip through our data pulling out concatenated JSON payloads.
         */
        loop {
            start = end + self.json_start(&contents[end..])?; 

            if start == len {
                break;
            }

            end = start + self.json_end(&contents[start..])?;

            self.ingest_datum(&contents[start..end])?;

            while self.byweight.len() >= self.config.maxrect as usize {
                self.trim();
            }

            nrecs += 1;
        }
        
        self.ingest_end();

        eprintln!("{} records processed, {} rectangles",
            nrecs, self.byweight.len());
        Ok(())
    }

    fn output_defs(&self, config: &StatemapSVGConfig,
        globals: &StatemapSVGGlobals)
    {
        println!("<defs>");

        println!("<script type=\"application/ecmascript\"><![CDATA[");

        println!("var globals = {{");
        let str = serde_json::to_string_pretty(&config).unwrap();
        println!("{},", &str[2..str.len() - 2]);

        let str = serde_json::to_string_pretty(&globals).unwrap();
        println!("{},", &str[2..str.len() - 2]);

        /*
         * Provide an "entities" member that has the descriptions for each
         * entity, if they have one.  Yes, this is a little goofy -- it
         * would make much more sense to have a "descriptions" member that
         * consists of strings named by entity -- but we're doing this for
         * the sake of compatibility with the legacy implementation, however
         * dubious..
         */
        println!("  entities: {{");

        let mut comma = "";

        for entity in self.entities.values() {
            let val = match entity.description {
                Some(ref description) => {
                    format!("description: \"{}\"", description)
                }
                _ => { "".to_string() }
            };

            println!("    {} \"{}\": {{ {} }}", comma, entity.name, val);
            comma = ",";
        }

        println!("  }}");
        println!("}};");

        /*
         * For now, we don't support tags at all.
         */
        println!("globals.tags = [];");
        println!("globals.notags = true;");

        /*
         * Now drop in our in-SVG code.
         */
        let lib = include_str!("statemap-svg.js");

        println!("{}\n]]></script>", lib);

        /*
         * Next up: CSS.
         */
        let css = include_str!("statemap-svg.css");

        println!("<style type=\"text/css\"><![CDATA[\n{}\n]]></style>", css);

        /*
         * And now other definitions.
         */
        let defs = include_str!("statemap-svg.defs");
        println!("{}", defs);

        println!("</defs>");
    }

    pub fn output_svg(&self, config: &StatemapSVGConfig) ->
        Result<(), Box<Error>>
    {
        struct Props {
            x: u32,
            y: u32,
            height: u32,
            width: u32,
            lheight: u32,
            spacing: u32
        };

        let output_data = |data: &HashMap<&String, Vec<String>>| {
            println!("<defs>");
            println!(r##"<script type="application/ecmascript"><![CDATA["##);

            println!("g_data = {{ ");
            let mut comma = "";

            for entity in data.keys() {
                println!("{}{}: [", comma, entity);

                let datum = data.get(entity).unwrap();

                for i in 0..datum.len() - 1 {
                    println!("{},", datum[i]);
                }

                println!("{}", datum[datum.len() - 1]);
                println!("]");
                comma = ",";
            }

            println!(r##"}} ]]></script></defs>"##);
        };

        let output_controls = |props: &Props| {
            let width = props.width / 4;
            let mut x = 0;
            let y = 0;

            let icons = vec![
                (include_str!("./icons/arrow-left-l.svg"), "panclick(50, 0)"),
                (include_str!("./icons/zoom-in.svg"), "zoomclick(1.25)"),
                (include_str!("./icons/zoom-out.svg"), "zoomclick(0.8)"),
                (include_str!("./icons/arrow-right-l.svg"), "panclick(-50, 0)")
            ];

            println!(r##"<svg x="{}px" y="{}px" width="{}px" height="{}px">"##,
                props.x, props.y, props.width, props.height);

            for i in 0..icons.len() {
                println!(r##"<svg x="{}px" y="{}px" width="{}px" height="{}px"
                    onclick="{}"><rect x="0px" y="0px" width="{}px" 
                    height="{}px" onclick="{}" class="button" />{}</svg>"##,
                    x, y, width, width, icons[i].1,
                    width, width, icons[i].1, icons[i].0);
                x += width;
            }

            println!("</svg>");
        };

        let output_legend = |props: &Props, colors: &[StatemapColor]| {
            let x = props.x;
            let mut y = props.y;
            let height = props.lheight;
            let width = props.width;

            for state in 0..self.states.len() {
                println!(r##"<rect x="{}" y="{}" width="{}" height="{}"
                    id="statemap-legend-{}" onclick="legendclick(evt, {})"
                    class="statemap-legend" style="fill:{}" />"##,
                    x, y, width, height, state, state, colors[state]);
                y += height + props.spacing;

                println!(concat!(r##"<text x="{}" y="{}" "##,
                    r##"class="statemap-legendlabel sansserif">{}</text>"##),
                    x + (width / 2), y, self.states[state].name);
                y += props.spacing;
            }
        };

        let metadata = match self.metadata {
            Some(ref metadata) => { metadata }
            _ => { return self.err("metadata not found in data stream"); }
        };

        #[allow(non_snake_case)]
        let timeWidth = self.entities.values().fold(self.config.end,
            |latest, e| {
                match e.start {
                    Some(start) => cmp::max(latest, start),
                    None => latest
               }
            }) - self.config.begin;

        let lmargin = config.legendWidth;
        let tmargin = 60;
        let rmargin = config.tagWidth;

        let height = (self.entities.len() as u32 *
            config.stripHeight) + tmargin;
        let width = config.stripWidth + lmargin + rmargin;

        let mut props = Props { x: 20, y: tmargin, height: 45,
            width: lmargin, lheight: 15, spacing: 10 };

        let lheight = tmargin + props.height + (self.states.len() as u32 *
            (props.lheight + (props.spacing * 2)));

        let globals = StatemapSVGGlobals {
            begin: self.config.begin,
            end: self.config.end,
            pixelWidth: config.stripWidth,
            pixelHeight: height - tmargin,
            totalHeight: cmp::max(height, lheight),
            timeWidth: timeWidth,
            lmargin: lmargin,
            tmargin: tmargin,
            entityPrefix: "statemap-entity-".to_string(),
            states: &self.states,
            start: &metadata.start,
            entityKind: match metadata.entityKind {
                Some(ref kind) => { kind }
                None => { "Entity" }
            }
        };

        /*
         * Sort our entities, by whatever criteria has been specified.
         */
        let sort = match config.sortby {
            None => None,
            Some(ref sortby) => {
                if metadata.states.contains_key(sortby) {
                    Some(metadata.states.get(sortby).unwrap().value)
                } else {
                    if sortby == "entity" {
                        /*
                         * A state of "entity" denotes that we should sort
                         * by entity name.
                         */
                        None
                    } else {
                        return self.err(&format!(concat!("cannot sort by ",
                            "state \"{}\": no such state"), sortby));
                    }
                }
            }
        };

        let entities = self.sort(sort);

        /*
         * Make sure that all of our colors are valid.
         */
        let mut colors: Vec<StatemapColor> = vec![];

        for i in 0..self.states.len() {
            match self.states[i].color {
                Some(ref name) => {
                    match StatemapColor::from_str(name) {
                        Ok(color) => colors.push(color),
                        Err(_err) => {
                            return self.err(&format!(concat!("illegal color",
                                "\"{}\" for state \"{}\""), name,
                                self.states[i].name));
                        }
                    }
                }
                None => colors.push(StatemapColor::random())
            }
        }

        println!(r##"<?xml version="1.0"?>
            <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
                "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
            <svg width="{}" height="{}"
                xmlns="http://www.w3.org/2000/svg"
                version="1.1"
                onload="init(evt)">"##, width, globals.totalHeight);

        self.output_defs(config, &globals);

        println!(r##"<svg x="{}px" y="{}px" width="{}px" height="{}px">"##,
            lmargin, tmargin, globals.pixelWidth, height - tmargin);

        /*
         * First, we drop down a background rectangle as big as our SVG. This
         * color will be changed dynamically to be a highlight color, and
         * then rectangles can be made transparent to become highlighted.
         */
        println!(concat!(r##"<rect x="0px" y="0px" width="{}px" "##,
            r##"height="{}px" fill="{}" id="statemap-highlight" />"##),
            globals.pixelWidth, height - tmargin, config.background);

        println!(r##"<g id="statemap" transform="matrix(1 0 0 1 0 0)">"##);

        let mut y = 0;
        let mut data = HashMap::new();

        for e in entities {
            let entity = self.entities.get(self.byid.get(e).unwrap()).unwrap();

            println!("{}", e);
            data.insert(&entity.name, 
                entity.output_svg(config, &globals, &colors, y));
            y += config.stripHeight;
        }

        println!("</g>");
        println!("</svg>");

        output_data(&data);

        /*
         * The border around our statemap.
         */
        println!(r##"<polygon class="statemap-border""##);
        println!(r##"  points="{} {}, {} {}, {} {}, {} {}"/>"##,
            lmargin, tmargin, lmargin + globals.pixelWidth, tmargin,
            lmargin + globals.pixelWidth, height, lmargin, height);

        println!(concat!(r##"<text x="{}" y="{}" "##,
            r##"class="statemap-title sansserif">{}</text>"##),
            lmargin + (globals.pixelWidth / 2), 16, metadata.title);

        println!(concat!(r##"<text x="{}" y="{}" class="statemap-timelabel"##,
            r##" sansserif" id="statemap-timelabel"></text>"##),
            lmargin + (globals.pixelWidth / 2), 34);

        println!(r##"<line x1="{}" y1="{}" x2="{}" y2="{}""##,
            lmargin + 10, 40, lmargin + globals.pixelWidth - 10, 40);
        println!(r##"class="statemap-timeline" />"##);

        props.width -= (2 * props.x) + 10;

        output_controls(&props);

        props.y += props.height;
        output_legend(&props, &colors);

        println!("</svg>");

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn metadata(config: Option<&Config>, metadata: &str) -> Statemap {
        let mut statemap;

        match config {
            Some(config) => { statemap = Statemap::new(&config); },
            None => {
                let config: Config = Default::default();
                statemap = Statemap::new(&config);
            }
        }

        match statemap.ingest_metadata(metadata) {
            Err(err) => { panic!("metadata incorrectly failed: {:?}", err); }
            Ok(_) => { statemap }
        }
    }

    fn minimal(config: Option<&Config>) -> Statemap {
        metadata(config, r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 0 },
                "one": {"value": 1 }
            }
        }"##)
    }

    fn data(config: Option<&Config>, data: Vec<&str>) -> Statemap {
        let mut statemap = minimal(config);

        for datum in data {
            match statemap.ingest_datum(datum) {
                Err(err) => { panic!("data incorrectly failed: {:?}", err); }
                Ok(_) => {}
            }
        }

        statemap
    }

    fn bad_metadata(metadata: &str, expected: &str) {
        let config: Config = Default::default();
        let mut statemap = Statemap::new(&config);

        match statemap.ingest_metadata(metadata) {
            Err(err) => {
                let errmsg = format!("{}", err);

                if errmsg.find(expected).is_none() {
                    panic!("error ('{}') did not contain '{}' as expected",
                        errmsg, expected);
                }
            },
            Ok(_) => { panic!("bad metadata succeeded!"); }
        }
    }

    fn bad_datum(operand: Option<Statemap>, datum: &str, expected: &str) {
        let mut statemap = match operand {
            Some(statemap) => statemap,
            None => {
                metadata(None, r##"{
                    "start": [ 0, 0 ],
                    "title": "Foo",
                    "states": {
                        "zero": {"value": 0 },
                        "one": {"value": 1 }
                    }
                }"##)
            }
        };

        match statemap.ingest_datum(datum) {
            Err(err) => {
                let errmsg = format!("{}", err);

                if errmsg.find(expected).is_none() {
                    panic!("error ('{}') did not contain '{}' as expected",
                        errmsg, expected);
                }
            },
            Ok(_) => { panic!("bad datum succeeded!"); }
        }
    }

    #[test]
    fn good_minimal() {
        metadata(None, r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 0 }
            }
        }"##);
    }

    #[test]
    fn bad_title_missing() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "states": {
                "zero": {"value": 0 }
            }
        }"##, "missing field `title`");
    }

    #[test]
    fn bad_start_missing() {
        bad_metadata(r##"{
            "title": "Foo",
            "states": {
                "zero": {"value": 0 }
            }
        }"##, "missing field `start`");
    }

    #[test]
    fn bad_start_badval() {
        bad_metadata(r##"{
            "start": [ -1, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 0 }
            }
        }"##, "invalid value: integer `-1`");
    }

    #[test]
    fn bad_start_tooshort() {
        bad_metadata(r##"{
            "start": [ 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 0 }
            }
        }"##, "\"start\" property must be a two element array");
    }

    #[test]
    fn bad_start_toolong() {
        bad_metadata(r##"{
            "start": [ 0, 0, 3 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 0 }
            }
        }"##, "\"start\" property must be a two element array");
    }

    #[test]
    fn bad_states_missing() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo"
        }"##, "missing field `states`");
    }

    #[test]
    fn bad_states_badmap() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": 123
        }"##, "expected a map");
    }

    #[test]
    fn bad_states_value_missing() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"notavalue": 0 }
            }
        }"##, "missing field `value`");
    }

    #[test]
    fn bad_states_value_bad() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": -1 }
            }
        }"##, "invalid value: integer `-1`");
    }

    #[test]
    fn bad_states_value_skipped1() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 0 },
                "one": {"value": 2 }
            }
        }"##, "state \"one\" has value (2) that exceeds maximum");
    }

    #[test]
    fn bad_states_value_toohigh() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 1 },
                "one": {"value": 2 }
            }
        }"##, "state \"one\" has value (2) that exceeds maximum");
    }

    #[test]
    fn bad_states_value_duplicate() {
        bad_metadata(r##"{
            "start": [ 0, 0 ],
            "title": "Foo",
            "states": {
                "zero": {"value": 1 },
                "one": {"value": 1 }
            }
        }"##, "has value (1) that conflicts");
    }

    #[test]
    fn basic() {
        let statemap = metadata(None, r##"{
            "start": [ 1528417173, 255882937 ],
            "title": "Foo",
            "host": "HA8S7MRD2",
            "entityKind": "Process",
            "states": {
                "on-cpu": {"value": 0, "color": "#2e9107" },
                "off-cpu-waiting": {"value": 1, "color": "#f9f9f9" },
                "off-cpu-semop": {"value": 2, "color": "#FF5733" },
                "off-cpu-blocked": {"value": 3, "color": "#C70039" },
                "off-cpu-zfs-read": {"value": 4, "color": "#FFC300" },
                "off-cpu-zfs-write": {"value": 5, "color": "#338AFF" },
                "off-cpu-zil-commit": {"value": 6, "color": "#66FFCC" },
                "off-cpu-tx-delay": {"value": 7, "color": "#e1ff00" },
                "off-cpu-dead": {"value": 8, "color": "#E0E0E0" }
            }
        }"##);
        assert_eq!(statemap.states.len(), 9);
        assert_eq!(statemap.states[0].name, "on-cpu");
        assert_eq!(statemap.states[0].color, Some("#2e9107".to_string()));
        assert_eq!(statemap.states[1].name, "off-cpu-waiting");
        assert_eq!(statemap.states[1].color, Some("#f9f9f9".to_string()));
        assert_eq!(statemap.states[8].name, "off-cpu-dead");
    }

    #[test]
    fn basic_datum() {
        let mut _statemap = data(None, vec![
            r##"{ "time": "156683", "entity": "foo", "state": 0 }"##
        ]);
    }

    #[test]
    fn basic_description() {
        let mut statemap = data(None, vec![
            r##"{ "time": "156683", "entity": "foo", "state": 0 }"##,
            r##"{ "entity": "foo", "description": "This is a foo!" }"##
        ]);

        assert_eq!(statemap.entity_lookup("foo").description,
            Some("This is a foo!".to_string()));
    }

    #[test]
    fn bad_datum_badtime() {
        bad_datum(None, r##"
            { "time": 156683, "entity": "foo", "state": 0 }
        "##, "illegal datum");
    }

    #[test]
    fn bad_datum_badtime_float() {
        bad_datum(None, r##"
            { "time": "156683.12", "entity": "foo", "state": 0 }
        "##, "illegal time value");
    }

    #[test]
    fn bad_datum_nostate() {
        bad_datum(None, r##"
            { "time": "156683", "entity": "foo" }
        "##, "illegal datum");
    }

    #[test]
    fn bad_datum_badstate() {
        bad_datum(None, r##"
            { "time": "156683", "entity": "foo", "state": 200 }
        "##, "illegal state value");
    }

    #[test]
    fn bad_datum_backwards() {
        let statemap = data(None, vec![
            r##"{ "time": "156683", "entity": "foo", "state": 0 }"##
        ]);

        bad_datum(Some(statemap), r##"
            { "time": "156682", "entity": "foo", "state": 1 }
        "##, "out of order with respect to prior time");
    }

    #[test]
    fn basic_data() {
        let statemap = data(None, vec![
            r##"{ "time": "100000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "200000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "300000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "400000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "500000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "600000", "entity": "foo", "state": 1 }"##
        ]);

        statemap.verify();
    }

    #[test]
    fn subsume() {
        let mut statemap = data(None, vec![
            r##"{ "time": "100000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "200000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "300000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "400000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "500000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "600000", "entity": "foo", "state": 1 }"##
        ]);

        statemap.print("Initial load");
        statemap.verify();
        statemap.subsume_apply_and_verify("foo", 100000);
        statemap.subsume_apply_and_verify("foo", 300000);
        statemap.subsume_apply_and_verify("foo", 100000);
    }

    #[test]
    fn subsume_right() {
        let mut statemap = data(None, vec![
            r##"{ "time": "100000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "200000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "300000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "400000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "500000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "600000", "entity": "foo", "state": 1 }"##
        ]);

        statemap.print("Initial load");
        statemap.verify();

        statemap.subsume_apply_and_verify("foo", 500000);
        statemap.subsume_apply_and_verify("foo", 400000);
        statemap.subsume_apply_and_verify("foo", 300000);
        statemap.subsume_apply_and_verify("foo", 200000);
    }

    #[test]
    fn subsume_middle() {
        let mut statemap = data(None, vec![
            r##"{ "time": "100000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "200000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "300000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "400000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "500000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "600000", "entity": "foo", "state": 1 }"##
        ]);

        statemap.print("Initial load");
        statemap.verify();
        statemap.subsume_apply_and_verify("foo", 300000);
        statemap.subsume_apply_and_verify("foo", 300000);
        statemap.subsume_apply_and_verify("foo", 200000);
    }

    #[test]
    fn trim() {
        let mut statemap = data(None, vec![
            r##"{ "time": "0", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "100", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "101", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "104", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "106", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "206", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "207", "entity": "foo", "state": 0 }"##
        ]);

        statemap.print("Initial");

        statemap.trim();
        statemap.verify();
        statemap.print("After first trim");

        statemap.trim();
        statemap.verify();
        statemap.print("After second trim");

        statemap.trim();
        statemap.verify();
        statemap.print("After third trim");
    }

    #[test]
    fn trim_insert() {
        let mut statemap = data(None, vec![
            r##"{ "time": "0", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "100", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "101", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "104", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "106", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "206", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "207", "entity": "foo", "state": 0 }"##
        ]);

        statemap.print("Initial");

        statemap.trim();
        statemap.verify();
        statemap.print("After first trim");

        let datum = r##"{ "time": "210", "entity": "foo", "state": 1 }"##;

        assert!(statemap.ingest_datum(datum).is_ok());
        statemap.verify();
        statemap.print("After insert");

        statemap.trim();
        statemap.verify();
        statemap.print("After second trim");
    }

    #[test]
    fn trim_multient() {
        let mut statemap = data(None, vec![
            r##"{ "time": "0", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "1000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "1010", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "1040", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "1060", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "2060", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "2070", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "0", "entity": "bar", "state": 0 }"##,
            r##"{ "time": "10", "entity": "bar", "state": 1 }"##,
        ]);

        statemap.print("Initial");

        statemap.trim();
        statemap.verify();
        statemap.print("After trim");
    }

    #[test]
    fn data_begin_time() {
        let mut config: Config = Default::default();
        config.begin = 200000;

        let statemap = data(Some(&config), vec![
            r##"{ "time": "100000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "200000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "300000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "400000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "500000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "600000", "entity": "foo", "state": 1 }"##
        ]);

        statemap.verify();
        statemap.print("Begin at 200000");

        let rects = statemap.get_rects("foo");
        assert_eq!(rects.len(), 4);
        assert_eq!(rects[0].0, 200000);
        assert_eq!(rects[0].1, 300000 - 200000);
    }

    #[test]
    fn data_begin_time_later() {
        let mut config: Config = Default::default();
        config.begin = 200001;

        let statemap = data(Some(&config), vec![
            r##"{ "time": "100000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "200000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "300000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "400000", "entity": "foo", "state": 1 }"##,
            r##"{ "time": "500000", "entity": "foo", "state": 0 }"##,
            r##"{ "time": "600000", "entity": "foo", "state": 1 }"##
        ]);

        statemap.verify();
        statemap.print("Begin at 200001");

        let rects = statemap.get_rects("foo");
        assert_eq!(rects.len(), 4);
        assert_eq!(rects[0].0, 200001);
        assert_eq!(rects[0].1, 300000 - 200001);
        assert_eq!((rects[0].2)[0], 0);
        assert_eq!((rects[0].2)[1], 300000 - 200001);
    }

    #[test]
    fn color_named() {
        let colors = vec![
            ("aliceblue", (240, 248, 255)),
            ("antiquewhite", (250, 235, 215)),
            ("aqua", (0, 255, 255)),
            ("aquamarine", (127, 255, 212)),
            ("azure", (240, 255, 255)),
            ("beige", (245, 245, 220)),
            ("bisque", (255, 228, 196)),
            ("black", (0, 0, 0)),
            ("blanchedalmond", (255, 235, 205)),
            ("blue", (0, 0, 255)),
            ("blueviolet", (138, 43, 226)),
            ("brown", (165, 42, 42)),
            ("burlywood", (222, 184, 135)),
            ("cadetblue", (95, 158, 160)),
            ("chartreuse", (127, 255, 0)),
            ("chocolate", (210, 105, 30)),
            ("coral", (255, 127, 80)),
            ("cornflowerblue", (100, 149, 237)),
            ("cornsilk", (255, 248, 220)),
            ("crimson", (220, 20, 60)),
            ("cyan", (0, 255, 255)),
            ("darkblue", (0, 0, 139)),
            ("darkcyan", (0, 139, 139)),
            ("darkgoldenrod", (184, 134, 11)),
            ("darkgray", (169, 169, 169)),
            ("darkgreen", (0, 100, 0)),
            ("darkgrey", (169, 169, 169)),
            ("darkkhaki", (189, 183, 107)),
            ("darkmagenta", (139, 0, 139)),
            ("darkolivegreen", (85, 107, 47)),
            ("darkorange", (255, 140, 0)),
            ("darkorchid", (153, 50, 204)),
            ("darkred", (139, 0, 0)),
            ("darksalmon", (233, 150, 122)),
            ("darkseagreen", (143, 188, 143)),
            ("darkslateblue", (72, 61, 139)),
            ("darkslategray", (47, 79, 79)),
            ("darkslategrey", (47, 79, 79)),
            ("darkturquoise", (0, 206, 209)),
            ("darkviolet", (148, 0, 211)),
            ("deeppink", (255, 20, 147)),
            ("deepskyblue", (0, 191, 255)),
            ("dimgray", (105, 105, 105)),
            ("dimgrey", (105, 105, 105)),
            ("dodgerblue", (30, 144, 255)),
            ("firebrick", (178, 34, 34)),
            ("floralwhite", (255, 250, 240)),
            ("forestgreen", (34, 139, 34)),
            ("fuchsia", (255, 0, 255)),
            ("gainsboro", (220, 220, 220)),
            ("ghostwhite", (248, 248, 255)),
            ("gold", (255, 215, 0)),
            ("goldenrod", (218, 165, 32)),
            ("gray", (128, 128, 128)),
            ("green", (0, 128, 0)),
            ("greenyellow", (173, 255, 47)),
            ("grey", (128, 128, 128)),
            ("honeydew", (240, 255, 240)),
            ("hotpink", (255, 105, 180)),
            ("indianred", (205, 92, 92)),
            ("indigo", (75, 0, 130)),
            ("ivory", (255, 255, 240)),
            ("khaki", (240, 230, 140)),
            ("lavender", (230, 230, 250)),
            ("lavenderblush", (255, 240, 245)),
            ("lawngreen", (124, 252, 0)),
            ("lemonchiffon", (255, 250, 205)),
            ("lightblue", (173, 216, 230)),
            ("lightcoral", (240, 128, 128)),
            ("lightcyan", (224, 255, 255)),
            ("lightgoldenrodyellow", (250, 250, 210)),
            ("lightgray", (211, 211, 211)),
            ("lightgreen", (144, 238, 144)),
            ("lightgrey", (211, 211, 211)),
            ("lightpink", (255, 182, 193)),
            ("lightsalmon", (255, 160, 122)),
            ("lightseagreen", (32, 178, 170)),
            ("lightskyblue", (135, 206, 250)),
            ("lightslategray", (119, 136, 153)),
            ("lightslategrey", (119, 136, 153)),
            ("lightsteelblue", (176, 196, 222)),
            ("lightyellow", (255, 255, 224)),
            ("lime", (0, 255, 0)),
            ("limegreen", (50, 205, 50)),
            ("linen", (250, 240, 230)),
            ("magenta", (255, 0, 255)),
            ("maroon", (128, 0, 0)),
            ("mediumaquamarine", (102, 205, 170)),
            ("mediumblue", (0, 0, 205)),
            ("mediumorchid", (186, 85, 211)),
            ("mediumpurple", (147, 112, 219)),
            ("mediumseagreen", (60, 179, 113)),
            ("mediumslateblue", (123, 104, 238)),
            ("mediumspringgreen", (0, 250, 154)),
            ("mediumturquoise", (72, 209, 204)),
            ("mediumvioletred", (199, 21, 133)),
            ("midnightblue", (25, 25, 112)),
            ("mintcream", (245, 255, 250)),
            ("mistyrose", (255, 228, 225)),
            ("moccasin", (255, 228, 181)),
            ("navajowhite", (255, 222, 173)),
            ("navy", (0, 0, 128)),
            ("oldlace", (253, 245, 230)),
            ("olive", (128, 128, 0)),
            ("olivedrab", (107, 142, 35)),
            ("orange", (255, 165, 0)),
            ("orangered", (255, 69, 0)),
            ("orchid", (218, 112, 214)),
            ("palegoldenrod", (238, 232, 170)),
            ("palegreen", (152, 251, 152)),
            ("paleturquoise", (175, 238, 238)),
            ("palevioletred", (219, 112, 147)),
            ("papayawhip", (255, 239, 213)),
            ("peachpuff", (255, 218, 185)),
            ("peru", (205, 133, 63)),
            ("pink", (255, 192, 203)),
            ("plum", (221, 160, 221)),
            ("powderblue", (176, 224, 230)),
            ("purple", (128, 0, 128)),
            ("rebeccapurple", (102, 51, 153)),
            ("red", (255, 0, 0)),
            ("rosybrown", (188, 143, 143)),
            ("royalblue", (65, 105, 225)),
            ("saddlebrown", (139, 69, 19)),
            ("salmon", (250, 128, 114)),
            ("sandybrown", (244, 164, 96)),
            ("seagreen", (46, 139, 87)),
            ("seashell", (255, 245, 238)),
            ("sienna", (160, 82, 45)),
            ("silver", (192, 192, 192)),
            ("skyblue", (135, 206, 235)),
            ("slateblue", (106, 90, 205)),
            ("slategray", (112, 128, 144)),
            ("slategrey", (112, 128, 144)),
            ("snow", (255, 250, 250)),
            ("springgreen", (0, 255, 127)),
            ("steelblue", (70, 130, 180)),
            ("tan", (210, 180, 140)),
            ("teal", (0, 128, 128)),
            ("thistle", (216, 191, 216)),
            ("tomato", (255, 99, 71)),
            ("turquoise", (64, 224, 208)),
            ("violet", (238, 130, 238)),
            ("wheat", (245, 222, 179)),
            ("white", (255, 255, 255)),
            ("whitesmoke", (245, 245, 245)),
            ("yellow", (255, 255, 0)),
            ("yellowgreen", (154, 205, 50)),
        ];

        let notcolors = vec!["nixon", "yellowgreenybeeny", "#1234567",
            "1234567", "$123456", "#123456#" ];

        for i in 0..notcolors.len() {
            match StatemapColor::from_str(notcolors[i]) {
                Ok(color) => {
                    panic!("lookup of {} succeeded with {:?}!",
                        notcolors[i], color);
                },
                Err(err) => {
                    println!("lookup of {} failed with {}", notcolors[i], err);
                }
            }
        }

        for i in 0..colors.len() {
            match StatemapColor::from_str(colors[i].0) {
                Ok(color) => {
                    let out = format!("rgb({}, {}, {})",
                        (colors[i].1).0, (colors[i].1).1, (colors[i].1).2);
                    assert_eq!(out, color.to_string());
                },
                Err(err) => {
                    panic!("lookup of {} failed with {}!", colors[i].0, err);
                }
            }
        }
    }

    #[test]
    fn color_mix() {
        let red = StatemapColor::from_str("red").unwrap();
        let white = StatemapColor::from_str("white").unwrap();

        let tests = vec![
            (0.0, "rgb(255, 0, 0)"),
            (0.25, "rgb(255, 137, 137)"),
            (0.5, "rgb(255, 188, 188)"),
            (0.75, "rgb(255, 225, 225)"),
            (1.0, "rgb(255, 255, 255)"),
        ];

        for i in 0..tests.len() {
            assert_eq!(red._mix(&white, tests[i].0).to_string(), tests[i].1);
            assert_eq!(red._mix(&white, tests[i].0).to_string(),
                white._mix(&red, 1.0 - tests[i].0).to_string());
        }
    }

    #[test]
    fn color_mix_linear() {
        let color = StatemapColor::from_str("#2e9107").unwrap();
        let other = StatemapColor::from_str("#f9f9f9").unwrap();
        let ratio = 351500 as f64 / 840108 as f64;
        let mix = color._mix(&other, ratio as f32);

        println!("color={}, other={}, mix={}", color, other, mix);
    }

    #[test]
    fn color_mix_nonlinear() {
        let color = StatemapColor::from_str("#2e9107").unwrap();
        let other = StatemapColor::from_str("#f9f9f9").unwrap();
        let ratio = 351500 as f64 / 840108 as f64;
        let mix = color.mix_nonlinear(&other, ratio as f32);

        println!("color={}, other={}, mix={}", color, other, mix);
    }
}
